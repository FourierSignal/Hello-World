
================================================================================================================================
Q : Difference Binary-semaphore and Mutex ??
A:

Binary semaphores and mutexes are very similar
subtle difference: 
                      Binary semaphores                                    mutexes

                    No priority inheritance mechanism                        Mutexes are binary semaphores that include
                                                                              a priority inheritance mechanism
                                                                              
                                                                              
                    Binary semaphore a better choice                          better choice for implementing
                    for implementing synchronisation                          simple mutual exclusion
                    (between tasks or between tasks and an interrupt) 
                    
                    semaphore can be released by any process                 only process acquired can relaese mutex
                       
Q: what is Mutex purpose??                       
Q:what is priority inheritance ? what is it's role in Mutex objective ?
  
   mutex : like a token to guard a resource.
   When a task wishes to access the resource it must first obtain the token.
   When it has finished with the resource it must 'give' the token back-allowing other tasks to access resource.
   
  scenario: Low-pri-taskA obtains mutex, high-pri-taskC which also require same mutex, got sceduled very next moment. 
  Result :  high-prio-taskC gets blocked for mutex and now chance that a medium-pri-taskB gets oppurtunity to run and finish.
            After taskB ,Low-pri-taskA gets chance to execute and release the mutex. high-pri-taskA gets chance to execute only
            after { Medium-pri-taskB Execution time + time taken by Low-pri-taskA to relese mutex} = Unbounded amount of time,untill
            Medium-pri-taskB finishes.
  
  Affect : Priority Inversion occured b/w Medim-pri-taskB and High-pri-taskC
  can we mitigate the Affect?? : priority inheritance: can't avoid priority inversion but can minimise the affect
  
  Role of priority Inheritance of Mutex - In minimising the Priority Inversion 
        if a high-pri-taskC blocks while attempting to obtain a mutex that is currently held by a 
        low-pri-taskA,then the priority of the taskA holding the mutex is temporarily raised to that of the blocking taskC
        ==> this doesn't allow Medim-pri-taskB to run.
        Now High-pri-taskC will run as soon as Low-pri-taskB releases the Lock( still priority Inversion , but minimised effect)
        
 Q: can we use Mutex in INTR-Handler ??
 A: Interrupt handler should not block waiting for some task to release mutex(if that task obtined mutex), 
    so we cant use mutex in INTR-Handler
    
    
 
Q: Re-entrant code ?? 

need :  single threaded process : -> single flow of control => code need not be re-entrant.
        Multi threaded process : ->  same Functions and resources accessed by several threads concurrently.
                                     re-entrant Fn : protects the resource integrity.
  
  
            
  Kernel-Memory Allocation:
  32bit ===> 2^32 = 4GB virtual Memory space.
  kernel is limited to 1GB-Virtual and Physical Memory
  The kernel's memory is not pageable. 
  The kernel usually wants physically contiguous memory
  Often, the kernel must allocate the memory without sleeping
  
  
  void * kmalloc(size_t size, int flags); ==>  allocates contiguous memory in physical memory as well as virtual memory
  flag :
  GFP_KERNEL => kmalloc can put current process in sleep state if memory is low.
                used in process context code when it is safe to sleep.
  GFP_ATOMIC:- ensures that current process is not put to sleep if memory is low.
               This is the flag to use in interrupt handlers, bottom halves and other situations where you cannot sleep.
  
  kmalloc return the virtual address of first page allocated. On error it returns NULL.               
  
  
  void kfree(const void *ptr)
  
  When to use Kmalloc :-If memory required in driver needs to be contiguous in physical memory 
                        then we have to use kmalloc for allocation of memory.

void * vmalloc(undigned long size)
vmalloc allocates contigous memory in virtual memory but it doesn't guarantee that
        memory allocated in physical memory will be contiguous.
Upon successful allocation of memory it return virtual address of first byte of allocated memory block.
On failure it returns NULL.        
void *vfree(const void *ptr);

When to use vmalloc?
When you are sure that memory required will never needs to interact with hardware in future 
or we can if you required memory only for software purpose then we should use vmalloc for allocating memory.

                        
                        


  
  
               
               
  
  
   
   
   .
   
   
   
   
  
  


                       
                       
                       
                       
                       
================================================================================================================================                       
                       
                       
                       
                       
                       
