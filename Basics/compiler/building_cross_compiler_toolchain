The following is steps to build cross compilers.
Basically, all you have to do is to follow the following 9 steps.

    Download sources
    Set environment variables
    Build binutils
    Build bootstrap gcc
    Build newlib
    Build gcc again with newlib
    GDB with PSIM
    Compile your code
    Run 




1. What do you need?

First, you have to obtain the following source codes

    binutils http://www.gnu.org/software/binutils/
    GCC http://www.gnu.org/software/gcc/gcc.html
    newlib http://sources.redhat.com/newlib/
    GDB http://www.gnu.org/software/gdb/gdb.html 
    
    
    
2. Set environment variables

First, choose your taget such as powerpc-eabi, powerpc-elf, mips-elf, and so on
% export TARGET=powerpc-eabi
% export PREFIX=/usr/local/$TARGET
% export PATH=$PATH:$PREFIX/bin

3. Build binutils

% tar xjfv binutils-2.17.tar.bz2
% mkdir build-binutils
% cd build-binutils
% ../binutils-2.17/configure --target=$TARGET --prefix=$PREFIX
% make all
% make install


4. Build bootstrap GCC

% tar xjfv gcc-4.1.1.tar.bz2
% mkdir build-gcc
% cd build-gcc
% ../gcc-4.1.1/configure --target=$TARGET --prefix=$PREFIX --without-headers --with-newlib  --with-gnu-as --with-gnu-ld
% make all-gcc
% make install-gcc

--with-gnu-as --with-gnu-ld prevents native assembler on certain architectures. (for others, these do not have any effects)
5. Build newlib

Newlib provides standard C library for embedded systems

% tar xzfv newlib-1.14.0.tar.gz 
% mkdir build-newlib
% cd build-newlib
% ../newlib-1.14.0/configure --target=$TARGET --prefix=$PREFIX
% make all
% make install

6. Build GCC again with newlib

% cd build-gcc
% ../gcc-4.1.1/configure --target=$TARGET --prefix=$PREFIX --with-newlib --with-gnu-as --with-gnu-ld --disable-shared --disable-libssp
% make all
% make install

7. GDB with PSIM

% tar xjfv gdb-6.3.tar.bz2  
% mkdir build-gdb
% cd build-gdb
% ../gdb-6.3/configure --target=$TARGET --prefix=$PREFIX --enable-sim-powerpc
--enable-sim-stdio
% make all
% make install

Congratulations! You build your tool chain

8. Compile your code

Now, it's time to compile your code.

% powerpc-eabi-gcc -mcpu=405 hello.c -o hello -msim
% mips-elf-gcc -Tidt.ld -mips4 hello.c -o hello

-T option specifies libraries that include start code.

To Compile with specific Memory map

% powerpc-eabi-gcc -Wl,-Ttext,0x4000,-Tdata,0xf000 hello.c -msim
(-Wl,-Ttext,0x4000,-Tdata,0x10000)

9. Run

% powerpc-eabi-run hello
% mips-elf-run hello


##############################################



AArch64 Linux hosted cross compilers

AArch32 bare-metal target (arm-none-eabi)

    gcc-arm-10.2-2020.11-aarch64-arm-none-eabi.tar.xz
 

 

AArch32 target with hard float (arm-none-linux-gnueabihf)

    gcc-arm-10.2-2020.11-aarch64-arm-none-linux-gnueabihf.tar.xz
    

 

AArch64 ELF bare-metal target (aarch64-none-elf)

    gcc-arm-10.2-2020.11-aarch64-aarch64-none-elf.tar.xz
    

gcc-arm-linux-gnueabi:  
targets ARM architecture,
has no vendor, 
creates binaries that run on the Linux operating system,
and usesthe GNU EABI.



"arm-eabi-gcc" you have the Linux system C library which will make calls into the kerne
arm-none-eabi: This toolchain targets the ARM architecture, has no vendor, does not target any operating system, and complies with the ARM EABI.

arm-none-linux-gnueabi: This toolchain targets the ARM architecture, has no vendor, creates binaries that run on the Linux operating system, and uses the GNU EABI. It is used to target ARM-based Linux systems.

arm-elf toolchain generates obj code for some OS which support executing elf format (example linux ABI). OS will control executing of your program.

arm-none-eabi toolchain generates obj code for micro-controllers or microprocessors (for bare metal, this will be EABI - embedded ABI). This code are downloaded to clean flash of MC and core of MC start executing it after power-on. No OS, extended command set, no possibility for linking with shared modules.


Unix cross compilers are loosely named using a convention of the form  
arch[-vendor][-os]-abi.

The arch refers to the target architecture, which in our case is ARM. 

The vendor nominally refers to thetoolchain supplier.

The os refers to the target operating system, if any,
and is used to decide which libraries(e.g.  newlib,  glibc,  crt0,  etc.) to link and which syscall conventions to employ.

The abi specifies: which application binary interface convention is being employed,
which ensures that binaries generated by different tools can interoperate.


 


############################################################################################

export HOME=/home/jaguar

export REL_PATH=$HOME/Jaguar_workspace/Embedded/RSP3_revB/toolchains

export INSTALL_DIR=$REL_PATH/gcc_from_GNU/install_toolchain


export TARGET=aarch64-eabi
export PREFIX=$INSTALL_DIR/$TARGET
export PATH=$PATH:$PREFIX/bin

tar xjfv binutils-2.36.tar.xz
mkdir build-binutils
cd build-binutils
../binutils-2.17/configure --target=$TARGET --prefix=$PREFIX
make all
make install

failed with 
*** BFD does not support target aarch64-unknown-eabi.
*** Look in bfd/config.bfd for supported targets.

The Binary File Descriptor library (BFD) is the GNU Project's main mechanism for
the portable manipulation of object files in a variety of formats.
As of 2003, it supports approximately 50 file formats for some 25 instruction set architectures


BFD is a package which allows applications to use the same routines to operate on object files
whatever the object file format. 
A new object file format can be supported simply by creating a new BFD back end and adding it to the library. 

export TARGET=aarch64-elf solves this problem because BFD does not support eabi



********************************
To compile binutils
export HOME=/home/jaguar
export REL_PATH=$HOME/Jaguar_workspace/Embedded/RSP3_revB/toolchains
export INSTALL_DIR=$REL_PATH/gcc_from_GNU/install_toolchain
export TARGET=aarch64-eabi
export PREFIX=$INSTALL_DIR/$TARGET

tar xjfv binutils-2.36.tar.xz
mkdir build-binutils
cd build-binutils
../binutils-2.17/configure --target=$TARGET --prefix=$PREFIX
make all
make install
**************************************************************

installation:

[jaguar@jaguar-macbookpro114 aarch64-elf]$ pwd
/home/jaguar/Jaguar_workspace/Embedded/RSP3_revB/toolchains/gcc_from_GNU/install_toolchain/aarch64-elf
[jaguar@jaguar-macbookpro114 aarch64-elf]$ ls
aarch64-elf  bin  lib  share
[jaguar@jaguar-macbookpro114 aarch64-elf]$ 


binutils---->

[jaguar@jaguar-macbookpro114 aarch64-elf]$ pwd
/home/jaguar/Jaguar_workspace/Embedded/RSP3_revB/toolchains/gcc_from_GNU/install_toolchain/aarch64-elf
[jaguar@jaguar-macbookpro114 aarch64-elf]$ ls bin/
aarch64-elf-addr2line  aarch64-elf-ld       aarch64-elf-readelf
aarch64-elf-ar         aarch64-elf-ld.bfd   aarch64-elf-size
aarch64-elf-as         aarch64-elf-nm       aarch64-elf-strings
aarch64-elf-c++filt    aarch64-elf-objcopy  aarch64-elf-strip
aarch64-elf-elfedit    aarch64-elf-objdump
aarch64-elf-gprof      aarch64-elf-ranlib
[jaguar@jaguar-macbookpro114 aarch64-elf]$ 



###################################################################


Build bootstrap GCC

cd gcc
mkdir build-gcc
cd build-gcc
../gcc-4.1.1/configure --target=$TARGET --prefix=$PREFIX --without-headers --with-newlib  --with-gnu-as --with-gnu-ld
make all-gcc
make install-gcc

--with-gnu-as --with-gnu-ld prevents native assembler on certain architectures. (for others, these do not have any effects)

###################################################################################################################


git clone git://sourceware.org/git/newlib-cygwin.git
or
ftp://sourceware.org/pub/newlib/


