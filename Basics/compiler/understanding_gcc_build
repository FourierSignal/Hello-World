
building cross tool chain: for embedded platforms / for nodes in a cluster of computers in a distributed computation

----------------------

building a cross toolchain is more involved than building a native toolchain.
because of instrinsic dependencies between parts of toolchain, which must be resolved explicitly.

References: compiler specific information: A.V.aho,R.sethi,JD.ullman compilers:principles,techniques and tools

Parts of compiler:
-------------------
C preprocessor:
remove comments,(include header files,conditional compiling)-based on preprocessing directives
preprocessing requires header files of libraies used by application.
on most systems preprocessor defines platform specific macros and
it must be configured to include platform specific headers. Hence preprocessor is not really platform independent.
In many compilers it is included as a part, for performance and to solve data flow issues 

compiler: 

responsible for converting c-code to assemby.
some times compilers may include preprocessor and/or assembler as their integral part.
compiler can be divided into : front-end , back-end
front-end:  transforming C source into a proprietary  intermediate language.
this intermediate language is independent of src and destination platform language , making frontend independent 
of destination platform
backend: intermediate language ---> assembler code
as assembly language is platform dependent, backend is also platform dependent.
Hence whole compiler is not platform independent.

assembler:
assembly code ---> relocatable binary object code.
relocatable means there is no absolute address built into object code.
object code files include 
table of exported symbols,which are used by other object files.
undefined symbols that require definition in other object files.

Linker:
It puts all binary object files into one file, replacing markers by absolute addresses
and linking function calls/symbolsaccess to other object files where symbols are actually defined.
some of these object files might be fetched from external libraries.



binutils   --> has assembler and linker
Clibrary - glibc /newlib/uclib
gcc




glibc and gcc require binutils - so compile binutils first.


gcc comes with a library libgcc which needs glibc
inter dependency between gcc and glibc


so we compile  primitive gcc.
If primitive gcc compiles full we are lucky.
if primitive gcc fails because of some dependency.we have to install incomplete compiler 

with this incomplete gcc compiler , we can build some parts of C library
with the incomplete Clibrary , we can try building full gcc compiler.
if have to iterate between incomplete gcc compiler and incomplete c library
at least untill full C-library is built

the simplest way of installing incomplete gcc is to use make; make install with -k option
so that make continues even with errors,skipping the failing parts(supporting libraries).


glibc building
--host should be different  as glibc should run on target
--prefix should also be different as it should be placed in target specific sub directory within the installation directory
additionally we need to tell where kerenel heads are available

after installing glibc 
 copy kernel headers into target specific directory
 include/linux --- into  arm-linux/include/linux
 include/asm-arm --- into arm-linux/include/asm
 latest kerenels also want 
 include/asm-generic --- into arm-linux/include/asm-generic
 
 building Full-gcc compiler
  rebuild gcc compiler with all languages and runtime libs
  






