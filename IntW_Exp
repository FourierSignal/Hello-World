July17/2016: For NVIDIA through Aricent: Kiran kumar bobbu(Aricent)

which drivers you worked on?? Have you worked on USB?

EEPROM-driver:
How do you read 10 bytes from EPROM? what is the use case of EPROM driver written?

when are the tasks created in your project compile time or runtime? 
how to create tasks @ runtime?
when the sceduler is invoked? how to invoke it?

what is done in your device open ? ---could not able to put forward steps (better write @ some place - so glancing before going to intw may help)
what is device Initialisation . how you did it for EEPROM?
What is pinmuxing? what is pinconfiguration? how you did it?
after pinmux what you did ? - clock Initialisation
what is clock initialisation ? how you done this --> more detailed answer could have given 
then what other things you done during device Initialisation?

If you wrote 10 bytes into UART buffer.and about to Enable the TX-Interrupt.but there is 
context switch suddenly. How do you manage the situation??


what are memory barriers?
What is out of order Execution?
two instructions of Equal execution time may get executed out of order .  why??

How do you write PS command of Linux? 
Iterate through task_struct list and display the state of process
From where do you get the task_struct list ?? 
what do you pass to / how do you ask to get state of processes??

Insert a node in tree.
delete a node from tree.
program to check a flag and update the satus to user?

From where do you get the syscall number in system-call?

what happens during  context switch from user space to kernel ??

How do you get the boot-args during run time ?

usrspace stack vs kernel space stack?

what is copy_to_user and copy_from-user? how they help in security??
you should know : page-tables,security in linux,user space and kernel space linux,ioremap

Feedback given by interviewer:
If you have Enough Knowledge , then Even if you don't have Project Experience: you will be hired.
you are going 2 steps in , but not the further 3 steps where you will touch bottom.
get Indepth Knowledge? dont do trial and Error? Analyse Each step why you are doing.
go through all course of action - from inserting usb stick till notification appears on screen
If you come 2 days befor i could have hired you,...those positions are filled .
now we need person very thourogh and well experienced.

Self Asseesment :
 not going In depth - not understanding thoroughly Each step.
 not Adventerous Enough to Experimentation : Learning new concepts, new subsystems,new devices 
 not doing work thouroughly and slowly: need more concentration
 not having self confidence: believe that you can get job, If you do the work thoroughly,Even if it is very small.
Interview-Asseesment:
- not presented the work done ..very well infront of interviwer
- no indepth knowledge about Each concept touched.


Assesment about Interviewer:
- initially doubtful about me wether i have worked on drivers?
- slowly gained belief on me.
- knowledge wise good but not the best,good in nature,no arrogance.
- felt ok about me , but not impressed Enough to hire me 
-this Intervie may be First round , If Qualified there may be client Interview : Nvidea
- since he felt i worked more on rtos and less on Linux side ..he didn't shoot many questions on Linux drivers
  other wise there may be questions on probe , driver registration etc.
- Also i did not putforth many of the things i have actually done.--other wise intw could have taken a different path 
  and he might have selected me.-- i could have mentioned iomap
  
Action:
----------------
Undersatnding UART driver thoroughly:

UART_INIT:
Allocate device numbers
create class for uart
Register the uart driver with Platform subsystem

UART_EXIT:
UnRegister the uart driver with Platform subsystem.
destroy the class uart
Free the device numbers allocated.












UART-Probe:
-----------
possible Q's: when does the probe is called ?
             what you do in probe of device(UART)

Enable UART TX and  RX pins through pin-ctrl subsystems  
Request_mem_region: Claim the memory region of 
Allocate the private object of UART
io-remap
Initialise and add the cdev
create the device node


UART-OPEN
--------------
UART-Initialisation:
---------------------
possible Q's:
      what is meant by device Initialisation? what you do during UART Initialisation?


uart clock Initialisation: 

software reset of device

protocol,Baud rate and Interrupt settings
FIFO and DMA settings
should be done as per the steps provided in data sheet.

Deatiled steps:
(A)
1)Initiate a software reset : set SOFTRESET bit in UART_SYSC
2)Wait for the end of the reset operation : poll RESET_DONE bit of UART_SYSS
(B)
Switch to Config-Mode B to Access register EFR
3) Baud-Rate setting:    9.6Kbps/ 1.843Kbps/ 3.6884Kbps  => Load divisor value in DLH,DLL
(C)
switch to operational-mode:
4) select b/w (single-granularity/N-granularity of FIFO-trigger level) /(  DMA mode ) ===>  TLR/TCR/FCR/SCR
5)set Tx-FIFO-trigger-level,Rx-FIFO-Trigger-level ,clear FIFO & Enable FIFO==> FCR-fifo control register.
6)Enable the baud-rate clock
(D)
Switch to Config-Mode B:
7)set data-width,stop-bit,no-parity ===> LCR
8)Disable the break-Ctrl   ===> LCR
(E)
9)switch to operational-mode:
10)Disable all the Interrupts ===> IER
11)set the UART mode: 16X / 13X ==> MDR1

Allocate Tx and RX Kfifo-buffers
Initialise WaitQ's for Read and Write operations
Request IRQ : Install ISR
Enable Rx-Interrupt only


UART_release:
-------------------
Disable Interrupts
free irq
Free Tx and RX kfifo's
Disable UART==> MDR1 reg


UART_READ:
----------------

if Intermediate Rx_kfifo_buffer is Empty : do not allow the proces to read.
      For a non-blocking read return -EAGAIN
      For blockable read : suspend the user process till data becomes available in Intermediate Rx_kfifo_buffer.
                 put the process in Read-Wait-queue on the condition:till data becomes available in Rx_kfifo_buffer
      once the data is available in Rx_kfifo_buffer : copy this to user buffer
      
      
UART_WRITE:
----------------
if Intermediate Rx_kfifo_buffer is full : do not allow the proces to write .
      For a non-blocking write return -EAGAIN
      For blockable write : suspend the user process till data becomes available in Intermediate Rx_kfifo_buffer.
              put the process in write-Wait-queue on the condition:till space is available in Tx_kfifo_buffer.
      once Tx_kfifo_buffer is empty : copy  user buffer to Tx_kfifo_buffer.

UART_FLUSH:
--------------
Flush - is called when a process closes its copy of the descriptor.
   suspend the user process till data in Tx_kfifo_buffer is emptied.
   put the process in write-Wait-queue on the condition:till Tx_kfifo_buffer is emptied.

object's flush method is invoked on any and every close(), 
the release method is invoked when the open file object's reference count drops to zero.


ISR of UART
----------------
check pending interrupts
Read IIR - : type of Interrupt which is higher in priority out of currently pending interrupts

if : RHR or Rx-timeout pending
copy all the available data from rx-uart-fifo  into Internal Rx-kfifo-buffer ( RXFIFOE- rx-fifo-empty flag of LSR)
mark Any sleeping RD-thread as Runnable => waku-up thread on RD-waitQ


if : THR pending 
copy data from tx-uart-fifo  into Internal Tx-kfifo-buffer till all spaces in tx-uart-fifo level are filled.
(check for  TXFIFOE -transmithold and shift registers are not empty condition)
mark Any sleeping WR-thread as Runnable => waku-up thread on WR-waitQ




















Watch dog timer:
http://www.embedded.com/design/debug-and-optimization/4402288/Watchdog-Timer
Before kicking the watch-dog timer:
1) perform set of sanity checks - kick the dog only if all sanity checks pass . if Any check fails - allow dog to bite
2) Record cause of sanity check failure in EPROM  - because sometimes it may be difficult to find cause after reset
3) bug-bite case ( if bite is due to S/W bug) : record the system state / currently active task state , valueble info
when trying to diagnose the problem.
4)




After dog-bite:
1)After reset , Examine status bit which indicates that bite occured : decide next course of Action
  continue running / swich to Fail safe/ display Error-Msg
2)record number of bites - to avoid persistently errant application resarting indefinitely
3)



choosing timeout Interval: ===> when to kick the dog??
--------------------------




objec-tives of watch-dog strategy in a multitasking system:
-----------------------------------------------------------
1)To detect an OS fail-ure that is preventing some or all ofthe tasks from running
2)To detect   an infinite loop in any task / deadlock b/w several tasks/
3)To detect   low-priority tasks not running due to  higher priority tasks hogging cpu 

open WDT
//Initialise WDT ?? here ?
If( Normal reboot)
skip below steps.
if( watch-dog reboot) //bootstatus flag of watchdog
 Increment the counter variable:kick_number
 if( kick_number > 3) //on that day
 Display : WDT+ERROR
 else
 read flag indicating Erraneous task From EPROM
 Display : flag=>task caused watchdog reset
 Read (state of system before reboot) / (state of task which caused reboot)
 Display : Diagnostic Info regading state of system before reboot
 
proceed only if(watchdog-jumper is inserted )
else
Display: Watch-dog Jumper not inserted. and stop.
//Initialise WDT ?? here ?
Initialise watch-dog timer and send open-device handle to WDT monito task
create task1:bug_task:
        configure a gpio-pin as i/p to get accept button press user i/p
        Register with watchdog-monitor task
        update flag1 only if switch is ON
create task2: periodic task with period 1ms
        Register with watchdog-monitor task
        update flag2 ,every 1ms
create task3: periodic task with period 1ms
        Register with watchdog-monitor task
        update flag3 ,every 2ms
create watch-dog_monitor task
       check the flags of all the periodic tasks
       If all flags updated - kick the dog              
       If any flag is not got updated -
             store the flag in EEPROM
             Avoid kicking the watch-dog
       
Analyse what are problems in kicking DOG from ISR??
Analyse How to monitor waiting tasks?


coding :

Application:

./FreeRTOS-Plus-Demo-1/Source/Examples/WDT/WDTManage.c
#define WATCHDOG_DEVICE		(const int8_t *)"/WWDT0/"  //aaa-zzz : wdt

	Peripheral_Descriptor_t WDT_handle;
		WDT_handle = FreeRTOS_open( WATCHDOG_DEVICE, flag );



BSP:

./FreeRTOS-Plus-Demo-1/Source/FreeRTOSIOConfig.h
#define ioconfigINCLUDE_WDT									1   //aaa-zzz : WDT

./FreeRTOS-Plus-Demo-1/Source/FreeRTOS-Products/FreeRTOS-Plus-IO/Device/LPC17xx/SupportedBoards/LPCXpresso17xx-base-board.h
#define boardAVAILABLE_DEVICES_LIST												\
{																				\
	{ ( const int8_t * const ) "/WWDT0/", eWWDT_TYPE, ( void * ) LPC_WWDT },	\
	{ ( const int8_t * const ) "/GPIO0/", eGPIO_TYPE, ( void * ) LPC_GPIO }		\
}

#define boardNUM_WWDTS				1  //aaa-zzz :wdt

./FreeRTOS-Plus-Demo-1/Source/FreeRTOS-Products/FreeRTOS-Plus-IO/Include/FreeRTOS_DriverInterface.h

typedef enum
{.....
	eWWDT_TYPE,
	eGPIO_TYPE
} Peripheral_Types_t;


/FreeRTOS-Plus-Demo-1/Source/FreeRTOS-Products/FreeRTOS-Plus-IO/Device/LPC17xx/FreeRTOS_lpc17xx_DriverInterface.c

  #include "FreeRTOS_wdt.h" //aaa-zzz : WDT

		case eWWDT_TYPE :

			#if ioconfigINCLUDE_WDT == 1   //aaa-zzz : WDT
			{
				xReturn = FreeRTOS_WWDT_open( pxPeripheralControl );
			}
			#endif
			break;


./FreeRTOS-Plus-Demo-1/Source/FreeRTOS-Products/FreeRTOS-Plus-IO/Device/LPC17xx/FreeRTOS_LPC17xx_wdt.c

#include <FreeRTOS_wdt.h> //aaa-zzz

portBASE_TYPE FreeRTOS_WWDT_open( Peripheral_Control_t * const pxPeripheralControl )
{


	return xReturn;
}


The Watchdog :  a divide by 4 fixed pre-scaler and a 32-bit counter. 
The clock is fed to the timer via a pre-scaler. The timer decrements when clocked.

The minimum value from which the counter decrements is 0xFF.

  
minimum Watchdog interval is = (T WDCLK * 256 * 4) = 10ms * 256 * 4 = 10ms x 4 x 256
maximum Watchdog interval is = (T WDCLK * 2^32 * 4) = 10ms x 2^32 x4 = 10ms x 4 x (2x1024x1024x1024)
                                                                     = 10ms x 4 x (2 x 1073741824)
                                                                     = 10ms x 4 x 2147483648

The watchdog timer block uses two clocks: PCLK and WDCLK. PCLK is used for the APB
accesses to the watchdog registers. The WDCLK is used for the watchdog timer counting.                                                                     
                                                                     
                                                    
                                                    


