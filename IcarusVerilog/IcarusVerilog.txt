https://github.com/steveicarus/iverilog: by Stephen Williams : written in c++
-------------------------------------------------

iverilog command :  This program invokes the preprocessor (ivlpp) and the compiler (ivl) with the proper command line options.

------------------------ hello.vl ----------------------------
module main();

initial
  begin
    $display("Hi there");
    $finish ;
  end

endmodule

--------------------------------------------------------------
To compile the program:   iverilog hello.vl
The above presumes that /usr/local/include and /usr/local/lib are part of the compiler search path, which is usually the case for gcc

To run the program:    ./a.out

You can use the -o switch to name the output command to be generated by the compiler.
iverilog -o hello hello.vl

Icarus Verilog is in development - as such it still only supports a (growing) subset of Verilog.
Icarus Verilog web page for the current state of support for Verilog,and in particular, browse the bug report database for reported unsupported constructs.

 Below is a description of some of the currently unsupported Verilog features.
 System functions are supported, but the return value is a little tricky. See SYSTEM FUNCTION TABLE FILES in the iverilog man page.
Specify blocks are parsed but ignored in general.
trireg is not supported. tri0 and tri1 are supported.
tran primitives, i.e. tran, tranif1, tranif0, rtran, rtranif1 and rtranif0 are not supported.

Nonstandard Constructs or Behaviors:
Icarus Verilog includes some features that are not part of the IEEE1364 standard, but have well-defined meaning, and also sometimes gives nonstandard (but extended) meanings to some features of the language that are defined. See the "extensions.txt" documentation for more details.

Builtin system functions:
Certain of the system functions have well-defined meanings, so can theoretically be evaluated at compile-time, instead of using runtime VPI code. Doing so means that VPI cannot override the definitions of functions handled in this manner. On the other hand, this makes them synthesizable, and also allows for more aggressive constant propagation.

    $bits,$signed,$sizeof,$unsigned are examples. Implementations of these system functions in VPI modules will be ignored.
    
Preprocessing Library Modules:
Icarus Verilog does preprocess modules that are loaded from libraries via the -y mechanism

    



parser : reads in Verilog (plus extensions) and generates an internal netlist.
          The output of the parse is a list of Module objects in "pform"
          ATTRIBUTES:  parser accepts, as an extension to Verilog, the $attribute module item.
          The syntax of the $attribute item is: $attribute (<identifier>, <key>, <value>);
          Attributes are [<key> <value>] pairs and are used to communicate with the various processing steps.
          Attributes can also be applied to gate types. When this is done, the attribute is given to every instantiation of the primitive.
          in this case The syntax for the attribute statement is the same, except that the <identifier> names a primitive earlier in the compilation 
          unit and the statement is placed in the global scope, instead of within a module.
          attributes are also occasionally used for communication between processing steps.Processing steps that are aware of other processing steps
          may place attributes on netlist objects to communicate information to later steps.
          Icarus Verilog also accepts the Verilog 2001 syntax for attributes. 
          
ivlpp:  does the preprocessing of directives

Elaboration: This phase takes the pform and generates a netlist.
             The driver selects (by user request or lucky guess) the root module to elaborate, resolves references and expands the instantiations 
             to form the design netlist.
             semantic checks,simple optimizations are performed
             The netlist includes all the behavioural descriptions, as well as gates and wires.
             human-readable version of the final, elaborated and optimized netlist can be seen by using the -N <path> flag to the compiler. 
             If elaboration succeeds, the final netlist (i.e., after optimizations but before code generation) will be dumped into the file named <path>.
             
             Elaboration is performed in two steps: scopes and parameters first, followed by the structural and behavioural elaboration.
             Scope Elaboration: scans through the pform looking for scopes and parameters. 
             A tree of NetScope objects is built up and placed in the Design object, with the root module represented by the root NetScope object.
             a scan of the NetScope tree to locate defparam assignments and defparam overrides are applied to the parameters.
             Netlist Elaboration: once NetScope tree fully formed, the elaboration runs through the pform again, 
             this time generating the structural and behavioural netlist.
             
             Parameters are elaborated and evaluated by now so all the constants of code generation are now known locally,
             so the netlist can be generated by simply passing through the pform.
             
Optimization: This is a collection of processing steps that perform optimizations that do not depend on the target technology. 
               eliminate null effect circuitry,combinational reduction,constant propagation etc
               ivl command line by the -F flags
               
Code Generation:  takes the design netlist and uses it to drive the code generator .
                    This may require transforming the design to suit the technology.
                     user selects the target code generator with the -t flag 
                     
                     
                     
                     
